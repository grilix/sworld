package sworld

import (
	"log"
	"math/rand"
	"time"

	"github.com/encryptio/alias"
)

// DropRate represents the rates for drops
type DropRate struct {
	Gold    float64
	Enemy   float64
	Item    float64
	Nothing float64
}

// Zone defines the type of enemies that will be found
// It's the base for creating a portal
type Zone struct {
	ID       string
	Name     string
	DropRate DropRate
}

// Portal is an instance of a Zone, where players can teleport to
type Portal struct {
	ID          string
	PortalStone PortalStone
	User        *User
	Character   *Character

	// TODO: Would this be the same as checking for C != nil ?
	IsOpen bool

	// C is the channel that communicates the portal closing event
	C chan bool

	startedAt  time.Time
	enemies    []*Enemy
	explorers  []*Explorer
	eventsRate *alias.Alias
	cleared    int
	seed       *rand.Rand
	//portalMap  []*PortalEvent
}

// PortalEvent is generated by the portal and sent to a character
// Eeach character is given its own event
type PortalEvent struct {
	Item  Item
	Enemy *Enemy
	Gold  int
}

// TimeLeft is the amount of time until the portal closes
func (p *Portal) TimeLeft() time.Duration {
	return p.PortalStone.Duration - time.Since(p.startedAt)
}

func (p *Portal) randomItemEvent() *PortalEvent {
	// TODO: Random item
	stone := p.randomPortalStone()

	log.Printf("   -> Item spawn %T%v", stone, stone)
	return &PortalEvent{Item: stone}
}

func (p *Portal) randomEnemyEvent(position int) *PortalEvent {
	if p.PortalStone.Level < 1 {
		return nil
	}

	enemy := NewEnemy(p, position)

	// FIXME: I don't really like this cross-dependency
	enemy.AddSkill(NewHitSkill(enemy))
	p.enemies = append(p.enemies, enemy)

	enemy.handleAttack()
	enemy.handleMove()

	return &PortalEvent{Enemy: enemy}
}

// RandomEvent creates a random event
func (p *Portal) RandomEvent(position int) *PortalEvent {
	eventID := int(p.eventsRate.Gen(p.seed))
	if p.cleared < position {
		p.cleared = position
	}

	// TODO
	switch eventID {
	case 0: // Gold
		return &PortalEvent{Gold: 1}
		//c.gold++
	case 1: // Enemy
		event := p.randomEnemyEvent(position)
		//p.enemies = append(p.enemies, event.Enemy)
		//c.enemies++
		return event
	case 2: // Item
		return p.randomItemEvent()
	}

	return nil
}

// GetRates returns an alias.Alias instance for drop rates
func (r DropRate) GetRates() (*alias.Alias, error) {
	return alias.New([]float64{
		r.Gold,
		r.Enemy,
		r.Item,
		r.Nothing,
	})
}

// OpenPortal opens a portal and sets a timer for closing it
func OpenPortal(user *User, stone PortalStone, closeFn func(*Portal)) (*Portal, error) {
	source := rand.NewSource(time.Now().UnixNano())

	p := &Portal{
		ID:          RandomID(16),
		PortalStone: stone,
		IsOpen:      true,
		User:        user,
		seed:        rand.New(source),
		enemies:     make([]*Enemy, 0, 10),
		explorers:   make([]*Explorer, 0, 1),
		startedAt:   time.Now(),
	}

	rate := stone.Zone.DropRate
	events, err := rate.GetRates()
	if err != nil {
		// FIXME: return err instead?
		panic("Can't initialize events")
	}
	p.eventsRate = events

	p.C = make(chan bool)
	go func() {
		defer close(p.C)

		tClose := time.NewTimer(stone.Duration)

		defer tClose.Stop()
		defer closeFn(p)
		for {
			select {
			case _, _ = <-p.C:
				return
			case _, _ = <-tClose.C:
				return
			}
		}
	}()

	return p, nil
}
